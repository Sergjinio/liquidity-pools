{
    "language": "Solidity",
    "sources": {
        "./src/liquidityPool/LiquidityPool.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.18;\n\n// Liquidity Pool implementation for Centrifuge Pools following the EIP4626 standard.\n// Each Liquidity Pool is a tokenized vault issuing shares as restricted ERC20 tokens against stable currency deposits based on the current share price.\n// Liquidity Pool vault: Liquidity Pool asset value.\n// asset: The underlying stable currency of the Liquidity Pool. Note: 1 Centrifuge Pool can have multiple Liquidity Pools for the same Tranche token with different underlying currencies (assets).\n// share: The restricted ERC-20 Liquidity pool token. Has a ratio (token price) of underlying assets exchanged on deposit/withdraw/redeem. Liquidity pool tokens on evm represent tranche tokens on centrifuge chain (even though in the current implementation one tranche token on centrifuge chain can be split across multiple liquidity pool tokens on EVM).\n\n// Challenges:\n// 1. Centrifuge Pools and corresponding Tranches live on Centchain having their liquidity spread across multiple chains.\n// Latest Tranche Token token price is not available in the same block and is updated in an async manner from Centrifuge chain. Deposit & Redemption previews can only be made based on the latest price updates from Centrifuge chain.\n// 2. Pool Epochs: Deposits into and redemptions from Centrifuge Pools are subject to epochs. Deposit and redemption orders are collected during 24H epoch periods\n// and filled during epoch execution following the rules of the underlying pool. Consequently, deposits and redemptions are not instanty possible and have to follow the epoch schedule.\n// LiquidityPool is extending the EIP4626 standard by 'requestRedeem' & 'requestDeposit' functions, where redeem and deposit orders are submitted to the pools to be included in the execution of the following epoch.\n// After execution users can use the redeem and withdraw functions to get their shares and/or assets from the pools.\n\n// other EIP4626 implementations\n// maple: https://github.com/maple-labs/pool-v2/blob/301f05b4fe5e9202eef988b4c8321310b4e86dc8/contracts/Pool.sol\n// yearn: https://github.com/yearn/yearn-vaults-v3/blob/master/contracts/VaultV3.vy\n\nimport \"../token/restricted.sol\";\n\ninterface LiquidityPoolLike {\n    function memberlist() external returns (address);\n    function hasMember(address) external returns (bool);\n    function file(bytes32 what, address data) external;\n    function mint(address, uint256) external;\n    function burn(address, uint256) external;\n    function balanceOf(address) external returns (uint256);\n    function transferFrom(address, address, uint256) external returns (bool);\n    function updateTokenPrice(uint128 _tokenPrice) external;\n    function asset() external returns (address);\n    function poolId() external returns (uint64);\n    function trancheId() external returns (bytes16);\n}\n\ninterface InvestmentManagerLike {\n    function processDeposit(address _receiver, uint256 _assets) external returns (uint256);\n    function processMint(address _receiver, uint256 _shares) external returns (uint256);\n    function processWithdraw(uint256 _assets, address _receiver, address _owner) external returns (uint256);\n    function processRedeem(uint256 _shares, address _receiver, address _owner) external returns (uint256);\n    function maxDeposit(address _user, address _tranche) external view returns (uint256);\n    function maxMint(address _user, address _tranche) external view returns (uint256);\n    function maxWithdraw(address _user, address _tranche) external view returns (uint256);\n    function maxRedeem(address _user, address _tranche) external view returns (uint256);\n    function requestRedeem(uint256 _shares, address _receiver) external;\n    function requestDeposit(uint256 _assets, address _receiver) external;\n    function collectInvest(uint64 poolId, bytes16 trancheId, address receiver, address currency) external;\n    function collectRedeem(uint64 poolId, bytes16 trancheId, address receiver, address currency) external;\n}\n\n/// @title LiquidityPool\n/// @author ilinzweilin\ncontract LiquidityPool is RestrictedToken {\n    InvestmentManagerLike public investmentManager;\n\n    address public asset; // underlying stable ERC-20 stable currency\n\n    uint128 public latestPrice; // share price\n    uint256 public lastPriceUpdate; // timestamp of the latest share price update\n\n    // ids of the existing centrifuge chain pool and tranche that the liquidity pool belongs to\n    uint64 public poolId;\n    bytes16 public trancheId;\n\n    // events\n    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n    event Withdraw(\n        address indexed sender, address indexed receiver, address indexed owner, uint256 assets, uint256 shares\n    );\n\n    constructor(uint8 _decimals) RestrictedToken(_decimals) {}\n\n    /// @dev investmentManager and asset address to be filed by the factory on deployment\n    function file(bytes32 _what, address _data) public override auth {\n        if (_what == \"investmentManager\") investmentManager = InvestmentManagerLike(_data);\n        else if (_what == \"asset\") asset = _data;\n        else if (_what == \"memberlist\") memberlist = MemberlistLike(_data);\n        else revert(\"LiquidityPool/file-unrecognized-param\");\n        emit File(_what, _data);\n    }\n\n    /// @dev Centrifuge chain pool information to be filed by factory on deployment\n    function setPoolDetails(uint64 _poolId, bytes16 _trancheId) public auth {\n        require(poolId == 0, \"LiquidityPool/pool-details-already-set\");\n        poolId = _poolId;\n        trancheId = _trancheId;\n    }\n\n    /// @dev The total amount of vault shares\n    /// @return Total amount of the underlying vault assets including accrued interest\n    function totalAssets() public view returns (uint256) {\n        return totalSupply * latestPrice;\n    }\n\n    /// @dev Calculates the amount of shares / tranche tokens that any user would get for the amount of assets provided. The calcultion is based on the token price from the most recent epoch retrieved from Centrifuge chain.\n    function convertToShares(uint256 _assets) public view returns (uint256 shares) {\n        shares = _assets / latestPrice;\n    }\n\n    /// @dev Calculates the asset value for an amount of shares / tranche tokens provided. The calcultion is based on the token price from the most recent epoch retrieved from Centrifuge chain.\n    function convertToAssets(uint256 _shares) public view returns (uint256 assets) {\n        assets = _shares * latestPrice;\n    }\n\n    /// @return Maximum amount of stable currency that can be deposited into the Tranche by the receiver after the epoch had been executed on Centrifuge chain.\n    function maxDeposit(address _receiver) public view returns (uint256) {\n        return investmentManager.maxDeposit(_receiver, address(this));\n    }\n\n    /// @return shares that any user would get for an amount of assets provided -> convertToShares\n    function previewDeposit(uint256 _assets) public view returns (uint256 shares) {\n        shares = convertToShares(_assets);\n    }\n\n    /// @dev request asset deposit for a receiver to be included in the next epoch execution. Asset is locked in the escrow on request submission\n    function requestDeposit(uint256 _assets) public {\n        investmentManager.requestDeposit(_assets, msg.sender);\n    }\n\n    /// @dev collect shares for deposited funds after pool epoch execution. maxMint is the max amount of shares that can be collected. Required assets must already be locked\n    /// maxDeposit is the amount of funds that was successfully invested into the pool on Centrifuge chain\n    function deposit(uint256 _assets, address _receiver) public returns (uint256 shares) {\n        shares = investmentManager.processDeposit(_receiver, _assets);\n        emit Deposit(address(this), _receiver, _assets, shares);\n    }\n\n    /// @dev collect shares for deposited funds after pool epoch execution. maxMint is the max amount of shares that can be collected. Required assets must already be locked\n    /// maxDeposit is the amount of funds that was successfully invested into the pool on Centrifuge chain\n    function mint(uint256 _shares, address _receiver) public returns (uint256 assets) {\n        // require(_receiver == msg.sender, \"LiquidityPool/not-authorized-to-mint\");\n        assets = investmentManager.processMint(_receiver, _shares);\n        emit Deposit(address(this), _receiver, assets, _shares);\n    }\n\n    /// @dev Maximum amount of shares that can be claimed by the receiver after the epoch has been executed on the Centrifuge chain side.\n    function maxMint(address _receiver) external view returns (uint256 maxShares) {\n        maxShares = investmentManager.maxMint(_receiver, address(this));\n    }\n\n    /// @return assets that any user would get for an amount of shares provided -> convertToAssets\n    function previewMint(uint256 _shares) external view returns (uint256 assets) {\n        assets = convertToAssets(_shares);\n    }\n\n    /// @dev request share redemption for a receiver to be included in the next epoch execution. Shares are locked in the escrow on request submission\n    function requestRedeem(uint256 _shares) public {\n        investmentManager.requestRedeem(_shares, msg.sender);\n    }\n\n    /// @return maxAssets that the receiver can withdraw\n    function maxWithdraw(address _receiver) public view returns (uint256 maxAssets) {\n        return investmentManager.maxWithdraw(_receiver, address(this));\n    }\n\n    /// @return shares that a user would need to redeem in order to receive the given amount of assets -> convertToAssets\n    function previewWithdraw(uint256 _assets) public view returns (uint256 shares) {\n        shares = convertToShares(_assets);\n    }\n\n    /// @dev Withdraw assets after successful epoch execution. Receiver will receive an exact amount of _assets for a certain amount of shares that has been redeemed from Owner during epoch execution.\n    /// @return shares that have been redeemed for the excat _assets amount\n    function withdraw(uint256 _assets, address _receiver, address _owner) public returns (uint256 shares) {\n        // check if messgae sender can spend owners funds\n        require(_owner == msg.sender, \"LiquidityPool/not-authorized-to-withdraw\");\n        uint256 sharesRedeemed = investmentManager.processWithdraw(_assets, _receiver, _owner);\n        emit Withdraw(address(this), _receiver, _owner, _assets, sharesRedeemed);\n        return sharesRedeemed;\n    }\n\n    /// @dev Max amount of shares that can be redeemed by the owner after redemption was requested\n    function maxRedeem(address _owner) public view returns (uint256 maxShares) {\n        return investmentManager.maxRedeem(_owner, address(this));\n    }\n\n    /// @return assets that any user could redeem for an given amount of shares -> convertToAssets\n    function previewRedeem(uint256 _shares) public view returns (uint256 assets) {\n        assets = convertToAssets(_shares);\n    }\n\n    /// @dev Redeem shares after successful epoch execution. Receiver will receive assets for the exact amount of redeemed shares from Owner after epoch execution.\n    /// @return assets currency payout for the exact amount of redeemed _shares\n    function redeem(uint256 _shares, address _receiver, address _owner) public returns (uint256 assets) {\n        require(_owner == msg.sender, \"LiquidityPool/not-authorized-to-redeem\");\n        uint256 currencyPayout = investmentManager.processRedeem(_shares, _receiver, _owner);\n        emit Withdraw(address(this), _receiver, _owner, currencyPayout, _shares);\n        return currencyPayout;\n    }\n\n    // auth functions\n    function updateTokenPrice(uint128 _tokenPrice) public auth {\n        latestPrice = _tokenPrice;\n        lastPriceUpdate = block.timestamp;\n    }\n\n    function collectRedeem(address _receiver) public {\n        investmentManager.collectRedeem(poolId, trancheId, _receiver, asset);\n    }\n\n    function collectInvest(address _receiver) public {\n        investmentManager.collectInvest(poolId, trancheId, _receiver, asset);\n    }\n}\n"
        },
        "./src/token/restricted.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity ^0.8.18;\n\nimport \"./erc20.sol\";\n\ninterface MemberlistLike {\n    function hasMember(address) external view returns (bool);\n    function member(address) external;\n}\n\ninterface ERC20Like {\n    function mint(address user, uint256 value) external;\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function balanceOf(address user) external view returns (uint256 value);\n    function burn(address user, uint256 value) external;\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n    function totalSupply() external returns (uint256);\n    function approve(address _spender, uint256 _value) external returns (bool);\n}\n\ninterface RestrictedTokenLike is ERC20Like {\n    function memberlist() external view returns (address);\n    function hasMember(address user) external view returns (bool);\n    function file(bytes32 contractName, address addr) external;\n}\n\ncontract RestrictedToken is ERC20 {\n    MemberlistLike public memberlist;\n\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n\n    constructor(uint8 decimals_) ERC20(decimals_) {}\n\n    modifier checkMember(address user) {\n        memberlist.member(user);\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) external virtual auth {\n        if (what == \"memberlist\") memberlist = MemberlistLike(data);\n        else revert(\"file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- Restrictions ---\n    function hasMember(address user) public view returns (bool) {\n        return memberlist.hasMember(user);\n    }\n\n    function transfer(address to, uint256 value) public override checkMember(to) returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public override checkMember(to) returns (bool) {\n        return super.transferFrom(from, to, value);\n    }\n\n    function mint(address to, uint256 value) public override checkMember(to) {\n        return super.mint(to, value);\n    }\n}\n"
        },
        "./src/token/erc20.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n// Copyright (C) 2017, 2018, 2019 dbrock, rain, mrchico\n// Copyright (C) 2021-2022 Foundation\npragma solidity ^0.8.18;\n\nimport \"./../auth/auth.sol\";\n\ninterface IERC1271 {\n    function isValidSignature(bytes32, bytes memory) external view returns (bytes4);\n}\n\n// Adapted from https://github.com/makerdao/xdomain-dss/blob/master/src/Dai.sol\ncontract ERC20 is Auth {\n    string public name;\n    string public symbol;\n    string public constant version = \"3\";\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public nonces;\n\n    // --- EIP712 niceties ---\n    uint256 public immutable deploymentChainId;\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    // --- Events ---\n    event File(bytes32 indexed what, string data);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint8 decimals_) {\n        decimals = decimals_;\n        wards[msg.sender] = 1;\n\n        deploymentChainId = block.chainid;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\n    }\n\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);\n    }\n\n    function file(bytes32 what, string memory data) external auth {\n        if (what == \"name\") name = data;\n        else if (what == \"symbol\") symbol = data;\n        else revert(\"ERC20/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- ERC20 Mutations ---\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        uint256 balance = balanceOf[msg.sender];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        unchecked {\n            balanceOf[msg.sender] = balance - value;\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(msg.sender, to, value);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        uint256 balance = balanceOf[from];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        if (from != msg.sender) {\n            uint256 allowed = allowance[from][msg.sender];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, \"ERC20/insufficient-allowance\");\n\n                unchecked {\n                    allowance[from][msg.sender] = allowed - value;\n                }\n            }\n        }\n\n        unchecked {\n            balanceOf[from] = balance - value;\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        allowance[msg.sender][spender] = value;\n\n        emit Approval(msg.sender, spender, value);\n\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) external returns (bool) {\n        uint256 newValue = allowance[msg.sender][spender] + addedValue;\n        allowance[msg.sender][spender] = newValue;\n\n        emit Approval(msg.sender, spender, newValue);\n\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool) {\n        uint256 allowed = allowance[msg.sender][spender];\n        require(allowed >= subtractedValue, \"ERC20/insufficient-allowance\");\n        unchecked {\n            allowed = allowed - subtractedValue;\n        }\n        allowance[msg.sender][spender] = allowed;\n\n        emit Approval(msg.sender, spender, allowed);\n\n        return true;\n    }\n\n    // --- Mint/Burn ---\n    function mint(address to, uint256 value) public virtual auth {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        unchecked {\n            balanceOf[to] = balanceOf[to] + value; // note: we don't need an overflow check here b/c balanceOf[to] <= totalSupply and there is an overflow check below\n        }\n        totalSupply = totalSupply + value;\n\n        emit Transfer(address(0), to, value);\n    }\n\n    function burn(address from, uint256 value) external {\n        uint256 balance = balanceOf[from];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        if (from != msg.sender) {\n            uint256 allowed = allowance[from][msg.sender];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, \"ERC20/insufficient-allowance\");\n\n                unchecked {\n                    allowance[from][msg.sender] = allowed - value;\n                }\n            }\n        }\n\n        unchecked {\n            balanceOf[from] = balance - value; // note: we don't need overflow checks b/c require(balance >= value) and balance <= totalSupply\n            totalSupply = totalSupply - value;\n        }\n\n        emit Transfer(from, address(0), value);\n    }\n\n    // --- Approve by signature ---\n    function _isValidSignature(address signer, bytes32 digest, bytes memory signature) internal view returns (bool) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            if (signer == ecrecover(digest, v, r, s)) {\n                return true;\n            }\n        }\n\n        (bool success, bytes memory result) =\n            signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, digest, signature));\n        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) public {\n        require(block.timestamp <= deadline, \"ERC20/permit-expired\");\n        require(owner != address(0), \"ERC20/invalid-owner\");\n\n        uint256 nonce;\n        unchecked {\n            nonce = nonces[owner]++;\n        }\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid),\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonce, deadline))\n            )\n        );\n\n        require(_isValidSignature(owner, digest, signature), \"ERC20/invalid-permit\");\n\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n    {\n        permit(owner, spender, value, deadline, abi.encodePacked(r, s, v));\n    }\n}\n"
        },
        "./src/auth/auth.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0-only\n// Copyright (C) Centrifuge 2020, based on MakerDAO dss https://github.com/makerdao/dss\npragma solidity ^0.8.18;\n\ncontract Auth {\n    mapping(address => uint256) public wards;\n\n    event Rely(address indexed usr);\n    event Deny(address indexed usr);\n\n    function rely(address usr) external auth {\n        wards[usr] = 1;\n        emit Rely(usr);\n    }\n\n    function deny(address usr) external auth {\n        wards[usr] = 0;\n        emit Deny(usr);\n    }\n\n    modifier auth() {\n        require(wards[msg.sender] == 1, \"not-authorized\");\n        _;\n    }\n}\n"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}