{
    "language": "Solidity",
    "sources": {
        "./src/token/Tranche.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\nimport {ERC20} from \"./ERC20.sol\";\nimport {IERC20} from \"../interfaces/IERC20.sol\";\n\ninterface TrancheTokenLike is IERC20 {\n    function mint(address user, uint256 value) external;\n    function burn(address user, uint256 value) external;\n    function file(bytes32 what, string memory data) external;\n    function file(bytes32 what, address data) external;\n    function restrictionManager() external view returns (address);\n    function addTrustedForwarder(address forwarder) external;\n    function checkTransferRestriction(address from, address to, uint256 value) external view returns (bool);\n}\n\ninterface ERC1404Like {\n    function detectTransferRestriction(address from, address to, uint256 value) external view returns (uint8);\n    function messageForTransferRestriction(uint8 restrictionCode) external view returns (string memory);\n    function SUCCESS_CODE() external view returns (uint8);\n}\n\n/// @title  Tranche Token\n/// @notice Extension of ERC20 + ERC1404 for tranche tokens,\n///         which manages the trusted forwarders for the ERC20 token, and ensures\n///         the transfer restrictions as defined in the RestrictionManager.\ncontract TrancheToken is ERC20 {\n    ERC1404Like public restrictionManager;\n\n    mapping(address => bool) public trustedForwarders;\n\n    // --- Events ---\n    event File(bytes32 indexed what, address data);\n    event AddTrustedForwarder(address indexed trustedForwarder);\n    event RemoveTrustedForwarder(address indexed trustedForwarder);\n\n    constructor(uint8 decimals_) ERC20(decimals_) {}\n\n    modifier restricted(address from, address to, uint256 value) {\n        uint8 restrictionCode = detectTransferRestriction(from, to, value);\n        require(restrictionCode == SUCCESS_CODE(), messageForTransferRestriction(restrictionCode));\n        _;\n    }\n\n    // --- Administration ---\n    function file(bytes32 what, address data) public auth {\n        if (what == \"restrictionManager\") restrictionManager = ERC1404Like(data);\n        else revert(\"TrancheToken/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    function addTrustedForwarder(address trustedForwarder) public auth {\n        trustedForwarders[trustedForwarder] = true;\n        emit AddTrustedForwarder(trustedForwarder);\n    }\n\n    function removeTrustedForwarder(address trustedForwarder) public auth {\n        trustedForwarders[trustedForwarder] = false;\n        emit RemoveTrustedForwarder(trustedForwarder);\n    }\n\n    // --- ERC20 overrides with restrictions ---\n    function transfer(address to, uint256 value) public override restricted(_msgSender(), to, value) returns (bool) {\n        return super.transfer(to, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value)\n        public\n        override\n        restricted(from, to, value)\n        returns (bool)\n    {\n        return super.transferFrom(from, to, value);\n    }\n\n    function mint(address to, uint256 value) public override restricted(_msgSender(), to, value) {\n        return super.mint(to, value);\n    }\n\n    // --- ERC1404 implementation ---\n    function detectTransferRestriction(address from, address to, uint256 value) public view returns (uint8) {\n        return restrictionManager.detectTransferRestriction(from, to, value);\n    }\n\n    function checkTransferRestriction(address from, address to, uint256 value) public view returns (bool) {\n        return restrictionManager.detectTransferRestriction(from, to, value) == SUCCESS_CODE();\n    }\n\n    function messageForTransferRestriction(uint8 restrictionCode) public view returns (string memory) {\n        return restrictionManager.messageForTransferRestriction(restrictionCode);\n    }\n\n    function SUCCESS_CODE() public view returns (uint8) {\n        return restrictionManager.SUCCESS_CODE();\n    }\n\n    // --- ERC2771Context ---\n    /// @dev Trusted forwarders can forward custom msg.sender and\n    ///      msg.data to the underlying ERC20 contract\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\n        return trustedForwarders[forwarder];\n    }\n\n    /// @dev Override for `msg.sender`. Defaults to the original `msg.sender` whenever\n    ///      a call is not performed by the trusted forwarder or the calldata length is less than\n    ///      20 bytes (an address length).\n    function _msgSender() internal view virtual override returns (address sender) {\n        if (isTrustedForwarder(msg.sender) && msg.data.length >= 20) {\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\n            /// @solidity memory-safe-assembly\n            assembly {\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n        } else {\n            return super._msgSender();\n        }\n    }\n}\n"
        },
        "./src/token/ERC20.sol": {
            "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.21;\n\ninterface IERC1271 {\n    function isValidSignature(bytes32, bytes memory) external view returns (bytes4);\n}\n\n/// @title  ERC20\n/// @notice Standard ERC20 implementation, with mint/burn functionality and permit logic.\n///         Includes ERC1271 context support to allow multiple trusted forwarders\n/// @author Modified from https://github.com/makerdao/xdomain-dss/blob/master/src/Dai.sol\ncontract ERC20 {\n    mapping(address => uint256) public wards;\n\n    string public name;\n    string public symbol;\n    uint8 public immutable decimals;\n    uint256 public totalSupply;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n    mapping(address => uint256) public nonces;\n\n    // --- EIP712 ---\n    bytes32 private immutable nameHash;\n    bytes32 private immutable versionHash;\n    uint256 public immutable deploymentChainId;\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    bytes32 public constant PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    // --- Events ---\n    event Rely(address indexed user);\n    event Deny(address indexed user);\n    event File(bytes32 indexed what, string data);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    constructor(uint8 decimals_) {\n        decimals = decimals_;\n        wards[_msgSender()] = 1;\n        emit Rely(_msgSender());\n\n        nameHash = keccak256(bytes(\"Centrifuge\"));\n        versionHash = keccak256(bytes(\"1\"));\n        deploymentChainId = block.chainid;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\n    }\n\n    modifier auth() {\n        // Custom auth modifier that uses _msgSender()\n        require(wards[_msgSender()] == 1, \"Auth/not-authorized\");\n        _;\n    }\n\n    function rely(address user) external auth {\n        wards[user] = 1;\n        emit Rely(user);\n    }\n\n    function deny(address user) external auth {\n        wards[user] = 0;\n        emit Deny(user);\n    }\n\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                // keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)')\n                0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f,\n                nameHash,\n                versionHash,\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);\n    }\n\n    function file(bytes32 what, string memory data) external auth {\n        if (what == \"name\") name = data;\n        else if (what == \"symbol\") symbol = data;\n        else revert(\"ERC20/file-unrecognized-param\");\n        emit File(what, data);\n    }\n\n    // --- ERC20 Mutations ---\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        uint256 balance = balanceOf[_msgSender()];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        unchecked {\n            balanceOf[_msgSender()] = balance - value;\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(_msgSender(), to, value);\n\n        return true;\n    }\n\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        uint256 balance = balanceOf[from];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        if (from != _msgSender()) {\n            uint256 allowed = allowance[from][_msgSender()];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, \"ERC20/insufficient-allowance\");\n                unchecked {\n                    allowance[from][_msgSender()] = allowed - value;\n                }\n            }\n        }\n\n        unchecked {\n            balanceOf[from] = balance - value;\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    function approve(address spender, uint256 value) external returns (bool) {\n        allowance[_msgSender()][spender] = value;\n\n        emit Approval(_msgSender(), spender, value);\n\n        return true;\n    }\n\n    // --- Mint/Burn ---\n    function mint(address to, uint256 value) public virtual auth {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        unchecked {\n            // We don't need an overflow check here b/c balanceOf[to] <= totalSupply\n            // and there is an overflow check below\n            balanceOf[to] = balanceOf[to] + value;\n        }\n        totalSupply = totalSupply + value;\n\n        emit Transfer(address(0), to, value);\n    }\n\n    function burn(address from, uint256 value) external auth {\n        uint256 balance = balanceOf[from];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        if (from != _msgSender()) {\n            uint256 allowed = allowance[from][_msgSender()];\n            if (allowed != type(uint256).max) {\n                require(allowed >= value, \"ERC20/insufficient-allowance\");\n\n                unchecked {\n                    allowance[from][_msgSender()] = allowed - value;\n                }\n            }\n        }\n\n        unchecked {\n            // We don't need overflow checks b/c require(balance >= value) and balance <= totalSupply\n            balanceOf[from] = balance - value;\n            totalSupply = totalSupply - value;\n        }\n\n        emit Transfer(from, address(0), value);\n    }\n\n    // --- Approve by signature ---\n    function _isValidSignature(address signer, bytes32 digest, bytes memory signature) internal view returns (bool) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            if (signer == ecrecover(digest, v, r, s)) {\n                return true;\n            }\n        }\n\n        (bool success, bytes memory result) =\n            signer.staticcall(abi.encodeWithSelector(IERC1271.isValidSignature.selector, digest, signature));\n        return (success && result.length == 32 && abi.decode(result, (bytes4)) == IERC1271.isValidSignature.selector);\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, bytes memory signature) public {\n        require(block.timestamp <= deadline, \"ERC20/permit-expired\");\n        require(owner != address(0), \"ERC20/invalid-owner\");\n\n        uint256 nonce;\n        unchecked {\n            nonce = nonces[owner]++;\n        }\n\n        bytes32 digest = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid),\n                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonce, deadline))\n            )\n        );\n\n        require(_isValidSignature(owner, digest, signature), \"ERC20/invalid-permit\");\n\n        allowance[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external\n    {\n        permit(owner, spender, value, deadline, abi.encodePacked(r, s, v));\n    }\n\n    // --- Fail-safe ---\n    function authTransferFrom(address from, address to, uint256 value) public auth returns (bool) {\n        require(to != address(0) && to != address(this), \"ERC20/invalid-address\");\n        uint256 balance = balanceOf[from];\n        require(balance >= value, \"ERC20/insufficient-balance\");\n\n        unchecked {\n            balanceOf[from] = balance - value;\n            balanceOf[to] += value;\n        }\n\n        emit Transfer(from, to, value);\n\n        return true;\n    }\n\n    // --- ERC1271 context ---\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n}\n"
        },
        "./src/interfaces/IERC20.sol": {
            "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.21;\n\n/// @title  IERC20\n/// @dev    Interface of the ERC20 standard as defined in the EIP.\n/// @author Modified from OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
        }
    },
    "settings": {
        "metadata": {
            "useLiteralContent": true
        },
        "optimizer": {
            "enabled": true,
            "runs": 200
        },
        "outputSelection": {
            "*": {
                "*": [
                    "abi",
                    "evm.bytecode",
                    "evm.deployedBytecode",
                    "evm.methodIdentifiers"
                ],
                "": [
                    "id",
                    "ast"
                ]
            }
        }
    }
}